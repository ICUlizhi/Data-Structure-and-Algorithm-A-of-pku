<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6-树</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            padding: 0;
            background-color: transparent;
        }
        blockquote {
            padding: 0 1em;
            color: #6a737d;
            border-left: 0.25em solid #dfe2e5;
            margin: 16px 0;
        }
        table {
            border-spacing: 0;
            border-collapse: collapse;
            margin: 16px 0;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #dfe2e5;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        img {
            max-width: 100%;
            box-sizing: content-box;
        }
        ul {
            padding-left: 2em;
        }
        li {
            margin: 0.25em 0;
        }
    </style>
</head>
<body>
    <p><h1>6 树</h1>
<h2>6.1 基本概念</h2>
和数学中的定义(无圈图)不太一样, 数算里的树是除了根之外所有点入度均为1的有向树, <strong>被摆放的很整齐</strong>.
> 同属于形式语言的数学语言和计算机语言, 前者只刻画性质, 而后者只保证可计算性. 我觉得树就是最好的例子. 根对于数学毫无意义, 但它在计算机语言中则是递归的起点
> 本质是因为数学语言的主体是推理者, 计算机语言的主体是电路
<li><strong>根</strong> : 唯一没有入度的节点</li>
<li><strong>子树<em>*, *</em>前驱</strong></li>
<li><strong>有向有序树</strong> :  有序是指子树间有次序</li>
  - 度为2的有序树 $\neq$ 二叉树 : 前者的单边节点的子树不分左右,都是第一子树
<li><strong>度数</strong> : 指出度, 即子树个数</li>
<li><strong>森林</strong> : 0或多棵不相交的树的集合</li>
<h3>树形结构的表示法</h3>
<li>树形表示法</li>
画树状图
<li>形式语言表示法</li>
定义节点集合和关系集合
<li>文氏图表示法</li>
用Venn 图的包含表示树的有向边
<li>凹入表表示法</li>
类似图书目录
<li>嵌套括号表示法</li>
迭代 Node()()


<h3>森林与二叉树的一一映射</h3>
<li>树或森林与二叉树存在一一对应的映射.</li>
<li><strong>森林$\rightarrow$二叉树</strong></li>
  - 数学语言:
    - <strong>加线</strong>：在树中所有相邻的兄弟之间加一连线(从左指向右). 
    - <strong>抹线</strong>：对树中每个结点, 除最左孩子外, 抹去该结点与孩子间的连线. 
    - <strong>整理</strong>
  - 伪代码:
  <pre><code>
  ForestToBinaryTree(F): \\F = [T_1,T_2,...T_n]
    空二叉树根节点 T
    F_1 = [T_11,T_12,...T_1m] \\ T_1除去根节点后的森林
    F_2 = [T_2,...T_n] \\ F除去T_1后的森林
    T->leftchild = ForestToBinaryTree(F_1)
    T->rightchild = ForestToBinaryTree(F_2)
    返回 T
  </code></pre>
<li><strong>二叉树$\rightarrow$森林</strong></li>
  - 以上变换的逆, 容易书写不做赘述
<h3>森林的遍历</h3>
<li>先根dfs = 前序遍历二叉树</li>
<li>后根dfs = 中序遍历二叉树</li>
<li>bfs : 同深度层被定义为二叉树储存结构的右斜线, 不能用二叉树的广度遍历模版</li>

<h2>6.2 树的存储</h2>
<h3>子结点表示法</h3>
实质上就是图的邻接表
<li>优势: </li>
  - 查孩子个数, 结点值, 归并与删除 
<li>劣势: </li>
  - 找兄弟结点
<h3>动态表示法</h3>
每个节点包含值和<strong>所有</strong>子节点指针
– 每个结点分配可变的存储空间 (若子结点数目发生变化, 需要重新分配存储空间)
<h3>"左孩子/右兄弟"表示法</h3>
每个节点包含: <strong><em>第一个**子节点, **</em>下一个</strong>兄弟节点, 节点值, (父亲节点)
> 笔记符号说明: *表示指针, ()表示备选
<li>优点：</li>
  - 节省空间
<li><strong>静态<em>*用数组实现, *</em>动态</strong>用类实现</li>
> 本质是二叉树与森林间的双射

> 一些方法
><strong>寻找父结点</strong>
>- 本质上是树/森林的遍历 
>  - 直观的做法用队列+while循环遍历森林即可, 递归方法则只适合树的遍历. 
>
><strong>镜像变换</strong>
>- 我认为应该递归, 对每个节点的处理是先有序地找到所有子节点, 再修改自身左子树指针和子节点的右兄弟指针, 最后对所有子节点递归. 
>
><strong>删除给定树根的子树</strong>
>- 非常繁琐
  


<h3>父指针表示法</h3>
每个结点仅保存指向其父结点的指针域 
<li>优点：</li>
	- 寻找父结点, 树根 
<li>缺点：</li>
	- 寻兄弟结点麻烦, 需要查询整个树结构. 
	- 属于<strong>无序树</strong> 
#### 并查集
由不相交子集构成的集合. 
<li>Find: 查询节点所在集合 </li>
<li>Union：归并两个集合</li>
<li>用于求解等价类问题 </li>
> 等价关系 : 自反, 对称, 传递

<strong>实现</strong> : 用一棵树代表一个集合, 树使用父指针表示法
<strong>Union</strong> : 将结点较少树的根结点指向结点较多树的根结点, 这可以把树的整体深度限制在O(logn). 
#### 路径压缩算法
查找 $X$ 的路径, 沿路径将所有节点的父指针都改为 $X$ 的树根
<li>产生极浅树</li>
<li>路径压缩使 Find 操作开销接近常数</li>
  - 对 $n$ 个结点进行 $n$ 次 Find 操作的开销为 $O(n\alpha(n))$, 约为 $\Theta(n\log^*n)$
    - $\alpha$ 是单变量Ackermann函数的逆
    - $\log^<em>n$ 为对 $n$ 不断取对数直至 $\leq 1$ 的次数, $\log^</em> 65536 = 4$
    - 
<h2>6.3 树的顺序存储</h2>
<h3>带右链的先根次序表示法</h3>
<li>任何结点的子树的所有结点都直接跟在该结点之后. </li>
<li>每棵子树的所有结点都聚集在一起, 中间不会插入别的结点. </li>
<li>任何一个分支结点后面跟的都是它的第一个子结点（<strong>如果存在的话</strong>）. </li>
<li>结点除包含本身数据外, 还附加两个表示结构的信息字段ltag（0有子结点, 1无子结点）, info, rlink（右指针, 指向下一个兄弟）. ltag可以重塑llink, 但是占用存储空间更少. </li>
<h3>6.3.2 带双标记位的先根次序表示法</h3>
<li>用rtag代替rlink. </li>
<li>rtag为1, 结点无兄弟；rtag为0, 有右兄弟. </li>
<li>当结点x的rtag为0时, 它的rlink应指向结点序列中排在以结点x为根的子树中最后结点的后面的那个结点y. </li>
<li><strong>有兄弟结点和无孩子结点一一对应, 满足栈特性. </strong></li>
结点x的兄弟结点y的确定方法：
!<a href="https://zhangzinuo-pictures.oss-cn-beijing.aliyuncs.com/img/202310270932278.png">image.png</a>
<strong>有兄弟就入栈, 无孩子就出栈</strong>. 
<h3>6.3.3 带度数的后根次序表示法</h3>
<li>info是结点的数据, degree是结点的度数. </li>
<li>将带度数的后根次序转化成森林时</li>
	- 从左至右进行扫描, 度为0的结点是叶子结点（也可看做一棵子树）. 
	- 当遇到度数非0（设为k）的结点时, 则排在该结点之前且离它最近的k个子树的根就是该结点的k个子结点. 
<li>利用栈实现：</li>
	- 遇到零度顶点就入栈. 
	- 遇到非零k度顶点就从栈中弹出k个节点作为其子结点, 然后将该非零顶点入栈. 
	- 持续扫描, 直至序列扫描完毕. 
<li>思考：</li>
	- 带度数的先根次序？ 从右到左即可. 
	- 带度数的层次次序？
<h3>6.3.4 带双标记的层次次序表示</h3>
<li>先看rtag：</li>
	- rtag=0：下一个结点即为其兄弟结点. 
	- rtag=1：无兄弟结点. 
<li>再看ltag：</li>
	- ltag=1：无孩子结点. 
	- ltag=0：有孩子结点. <—<strong>重点考虑</strong>
<li><strong>有孩子节点与无兄弟节点一一对应, 满足队列特性. </strong></li>
<li><strong>有孩子则入队列, 无兄弟则出队列</strong>. </li>
 

> <strong>求最大矩形面积</strong> : 给定 n 个非负整数, 代表柱状图上每个柱的高度（每个柱的宽度均为 1）, 求这个柱状图中最大的矩形面积. 

<li>O(n^3)</li>
  - 枚举所有左右边界可能性, 并且在边界内找最低的柱子, 枚举边界复杂度O(n^2), 找最低柱子O(n), 总复杂度O(n^3)
<li>O(n^2)</li>
  - 枚举每个柱子作为右边界, 往回枚举所有之前的柱子作为左边界, 枚举过程中记录最低柱子, 则最矮柱子\*左右边界距离为当前矩阵面积. 
  - 取所有这样的面积最大值, 右边界有O(n)种可能, 往回找比它矮的柱子也是O(n), 总复杂度为O(n^2)
<li>O(n)</li>
  - 关键：维护一个栈, 用于存储直方图柱子中的索引, 并保证栈中索引对应的柱子高度递增(<strong>单调栈</strong>)
  - 枚举直方图中的每一个柱子
  - 当栈为空, 或者当前柱子的高度大于栈顶柱子的高度时, 将当前柱子的索引压入栈. 
  - 当前柱子的高度小于或等于栈顶索引对应柱子的高度时, 持续从栈中弹出柱子, 直到栈为空或者栈顶柱子的高度小于当前柱子的高度. 弹出操作结束后, 压入当前柱子的索引. 
  - 对于每一个弹出的柱子, 计算以该柱子为高度向两边扩展能得到的最大宽度：
	- 若栈非空, 最大宽度为当前柱子到弹出柱子的距离(不含当前柱子)
	- 若栈为空, 最大宽度为到当前柱子为止的总柱子数减1, 根据高度与最大宽度来求当前矩形面积, 并更新最大面积. </p>
</body>
</html>